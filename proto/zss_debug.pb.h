// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zss_debug.proto

#ifndef PROTOBUF_zss_5fdebug_2eproto__INCLUDED
#define PROTOBUF_zss_5fdebug_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ZSS {
namespace Protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_zss_5fdebug_2eproto();
void protobuf_AssignDesc_zss_5fdebug_2eproto();
void protobuf_ShutdownFile_zss_5fdebug_2eproto();

class Point;
class Rectangle;
class Debug_Robot;
class Debug_Line;
class Debug_Arc;
class Debug_Polygon;
class Debug_Text;
class Debug_Curve_;
class Debug_Curve;
class Debug_Msg;
class Debug_Msgs;

enum Debug_Msg_Debug_Type {
  Debug_Msg_Debug_Type_ARC = 0,
  Debug_Msg_Debug_Type_LINE = 1,
  Debug_Msg_Debug_Type_TEXT = 2,
  Debug_Msg_Debug_Type_ROBOT = 3,
  Debug_Msg_Debug_Type_CURVE = 4,
  Debug_Msg_Debug_Type_POLYGON = 5
};
bool Debug_Msg_Debug_Type_IsValid(int value);
const Debug_Msg_Debug_Type Debug_Msg_Debug_Type_Debug_Type_MIN = Debug_Msg_Debug_Type_ARC;
const Debug_Msg_Debug_Type Debug_Msg_Debug_Type_Debug_Type_MAX = Debug_Msg_Debug_Type_POLYGON;
const int Debug_Msg_Debug_Type_Debug_Type_ARRAYSIZE = Debug_Msg_Debug_Type_Debug_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Debug_Msg_Debug_Type_descriptor();
inline const ::std::string& Debug_Msg_Debug_Type_Name(Debug_Msg_Debug_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Debug_Msg_Debug_Type_descriptor(), value);
}
inline bool Debug_Msg_Debug_Type_Parse(
    const ::std::string& name, Debug_Msg_Debug_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Debug_Msg_Debug_Type>(
    Debug_Msg_Debug_Type_descriptor(), name, value);
}
enum Debug_Msg_Color {
  Debug_Msg_Color_WHITE = 0,
  Debug_Msg_Color_RED = 1,
  Debug_Msg_Color_ORANGE = 2,
  Debug_Msg_Color_YELLOW = 3,
  Debug_Msg_Color_GREEN = 4,
  Debug_Msg_Color_CYAN = 5,
  Debug_Msg_Color_BLUE = 6,
  Debug_Msg_Color_PURPLE = 7,
  Debug_Msg_Color_GRAY = 8,
  Debug_Msg_Color_BLACK = 9
};
bool Debug_Msg_Color_IsValid(int value);
const Debug_Msg_Color Debug_Msg_Color_Color_MIN = Debug_Msg_Color_WHITE;
const Debug_Msg_Color Debug_Msg_Color_Color_MAX = Debug_Msg_Color_BLACK;
const int Debug_Msg_Color_Color_ARRAYSIZE = Debug_Msg_Color_Color_MAX + 1;

const ::google::protobuf::EnumDescriptor* Debug_Msg_Color_descriptor();
inline const ::std::string& Debug_Msg_Color_Name(Debug_Msg_Color value) {
  return ::google::protobuf::internal::NameOfEnum(
    Debug_Msg_Color_descriptor(), value);
}
inline bool Debug_Msg_Color_Parse(
    const ::std::string& name, Debug_Msg_Color* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Debug_Msg_Color>(
    Debug_Msg_Color_descriptor(), name, value);
}
// ===================================================================

class Point : public ::google::protobuf::Message {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  void Swap(Point* other);

  // implements Message ----------------------------------------------

  Point* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:ZSS.Protocol.Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  friend void  protobuf_AddDesc_zss_5fdebug_2eproto();
  friend void protobuf_AssignDesc_zss_5fdebug_2eproto();
  friend void protobuf_ShutdownFile_zss_5fdebug_2eproto();

  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class Rectangle : public ::google::protobuf::Message {
 public:
  Rectangle();
  virtual ~Rectangle();

  Rectangle(const Rectangle& from);

  inline Rectangle& operator=(const Rectangle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rectangle& default_instance();

  void Swap(Rectangle* other);

  // implements Message ----------------------------------------------

  Rectangle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Rectangle& from);
  void MergeFrom(const Rectangle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ZSS.Protocol.Point point1 = 1;
  inline bool has_point1() const;
  inline void clear_point1();
  static const int kPoint1FieldNumber = 1;
  inline const ::ZSS::Protocol::Point& point1() const;
  inline ::ZSS::Protocol::Point* mutable_point1();
  inline ::ZSS::Protocol::Point* release_point1();
  inline void set_allocated_point1(::ZSS::Protocol::Point* point1);

  // required .ZSS.Protocol.Point point2 = 2;
  inline bool has_point2() const;
  inline void clear_point2();
  static const int kPoint2FieldNumber = 2;
  inline const ::ZSS::Protocol::Point& point2() const;
  inline ::ZSS::Protocol::Point* mutable_point2();
  inline ::ZSS::Protocol::Point* release_point2();
  inline void set_allocated_point2(::ZSS::Protocol::Point* point2);

  // @@protoc_insertion_point(class_scope:ZSS.Protocol.Rectangle)
 private:
  inline void set_has_point1();
  inline void clear_has_point1();
  inline void set_has_point2();
  inline void clear_has_point2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ZSS::Protocol::Point* point1_;
  ::ZSS::Protocol::Point* point2_;
  friend void  protobuf_AddDesc_zss_5fdebug_2eproto();
  friend void protobuf_AssignDesc_zss_5fdebug_2eproto();
  friend void protobuf_ShutdownFile_zss_5fdebug_2eproto();

  void InitAsDefaultInstance();
  static Rectangle* default_instance_;
};
// -------------------------------------------------------------------

class Debug_Robot : public ::google::protobuf::Message {
 public:
  Debug_Robot();
  virtual ~Debug_Robot();

  Debug_Robot(const Debug_Robot& from);

  inline Debug_Robot& operator=(const Debug_Robot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Debug_Robot& default_instance();

  void Swap(Debug_Robot* other);

  // implements Message ----------------------------------------------

  Debug_Robot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Debug_Robot& from);
  void MergeFrom(const Debug_Robot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ZSS.Protocol.Point pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline const ::ZSS::Protocol::Point& pos() const;
  inline ::ZSS::Protocol::Point* mutable_pos();
  inline ::ZSS::Protocol::Point* release_pos();
  inline void set_allocated_pos(::ZSS::Protocol::Point* pos);

  // required float dir = 2;
  inline bool has_dir() const;
  inline void clear_dir();
  static const int kDirFieldNumber = 2;
  inline float dir() const;
  inline void set_dir(float value);

  // @@protoc_insertion_point(class_scope:ZSS.Protocol.Debug_Robot)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_dir();
  inline void clear_has_dir();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ZSS::Protocol::Point* pos_;
  float dir_;
  friend void  protobuf_AddDesc_zss_5fdebug_2eproto();
  friend void protobuf_AssignDesc_zss_5fdebug_2eproto();
  friend void protobuf_ShutdownFile_zss_5fdebug_2eproto();

  void InitAsDefaultInstance();
  static Debug_Robot* default_instance_;
};
// -------------------------------------------------------------------

class Debug_Line : public ::google::protobuf::Message {
 public:
  Debug_Line();
  virtual ~Debug_Line();

  Debug_Line(const Debug_Line& from);

  inline Debug_Line& operator=(const Debug_Line& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Debug_Line& default_instance();

  void Swap(Debug_Line* other);

  // implements Message ----------------------------------------------

  Debug_Line* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Debug_Line& from);
  void MergeFrom(const Debug_Line& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ZSS.Protocol.Point start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline const ::ZSS::Protocol::Point& start() const;
  inline ::ZSS::Protocol::Point* mutable_start();
  inline ::ZSS::Protocol::Point* release_start();
  inline void set_allocated_start(::ZSS::Protocol::Point* start);

  // required .ZSS.Protocol.Point end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline const ::ZSS::Protocol::Point& end() const;
  inline ::ZSS::Protocol::Point* mutable_end();
  inline ::ZSS::Protocol::Point* release_end();
  inline void set_allocated_end(::ZSS::Protocol::Point* end);

  // required bool FORWARD = 3;
  inline bool has_forward() const;
  inline void clear_forward();
  static const int kFORWARDFieldNumber = 3;
  inline bool forward() const;
  inline void set_forward(bool value);

  // required bool BACK = 4;
  inline bool has_back() const;
  inline void clear_back();
  static const int kBACKFieldNumber = 4;
  inline bool back() const;
  inline void set_back(bool value);

  // @@protoc_insertion_point(class_scope:ZSS.Protocol.Debug_Line)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_forward();
  inline void clear_has_forward();
  inline void set_has_back();
  inline void clear_has_back();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ZSS::Protocol::Point* start_;
  ::ZSS::Protocol::Point* end_;
  bool forward_;
  bool back_;
  friend void  protobuf_AddDesc_zss_5fdebug_2eproto();
  friend void protobuf_AssignDesc_zss_5fdebug_2eproto();
  friend void protobuf_ShutdownFile_zss_5fdebug_2eproto();

  void InitAsDefaultInstance();
  static Debug_Line* default_instance_;
};
// -------------------------------------------------------------------

class Debug_Arc : public ::google::protobuf::Message {
 public:
  Debug_Arc();
  virtual ~Debug_Arc();

  Debug_Arc(const Debug_Arc& from);

  inline Debug_Arc& operator=(const Debug_Arc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Debug_Arc& default_instance();

  void Swap(Debug_Arc* other);

  // implements Message ----------------------------------------------

  Debug_Arc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Debug_Arc& from);
  void MergeFrom(const Debug_Arc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ZSS.Protocol.Rectangle rectangle = 1;
  inline bool has_rectangle() const;
  inline void clear_rectangle();
  static const int kRectangleFieldNumber = 1;
  inline const ::ZSS::Protocol::Rectangle& rectangle() const;
  inline ::ZSS::Protocol::Rectangle* mutable_rectangle();
  inline ::ZSS::Protocol::Rectangle* release_rectangle();
  inline void set_allocated_rectangle(::ZSS::Protocol::Rectangle* rectangle);

  // required float start = 2;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 2;
  inline float start() const;
  inline void set_start(float value);

  // required float end = 3;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 3;
  inline float end() const;
  inline void set_end(float value);

  // required bool FILL = 4;
  inline bool has_fill() const;
  inline void clear_fill();
  static const int kFILLFieldNumber = 4;
  inline bool fill() const;
  inline void set_fill(bool value);

  // @@protoc_insertion_point(class_scope:ZSS.Protocol.Debug_Arc)
 private:
  inline void set_has_rectangle();
  inline void clear_has_rectangle();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_fill();
  inline void clear_has_fill();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ZSS::Protocol::Rectangle* rectangle_;
  float start_;
  float end_;
  bool fill_;
  friend void  protobuf_AddDesc_zss_5fdebug_2eproto();
  friend void protobuf_AssignDesc_zss_5fdebug_2eproto();
  friend void protobuf_ShutdownFile_zss_5fdebug_2eproto();

  void InitAsDefaultInstance();
  static Debug_Arc* default_instance_;
};
// -------------------------------------------------------------------

class Debug_Polygon : public ::google::protobuf::Message {
 public:
  Debug_Polygon();
  virtual ~Debug_Polygon();

  Debug_Polygon(const Debug_Polygon& from);

  inline Debug_Polygon& operator=(const Debug_Polygon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Debug_Polygon& default_instance();

  void Swap(Debug_Polygon* other);

  // implements Message ----------------------------------------------

  Debug_Polygon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Debug_Polygon& from);
  void MergeFrom(const Debug_Polygon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ZSS.Protocol.Point vertex = 1;
  inline int vertex_size() const;
  inline void clear_vertex();
  static const int kVertexFieldNumber = 1;
  inline const ::ZSS::Protocol::Point& vertex(int index) const;
  inline ::ZSS::Protocol::Point* mutable_vertex(int index);
  inline ::ZSS::Protocol::Point* add_vertex();
  inline const ::google::protobuf::RepeatedPtrField< ::ZSS::Protocol::Point >&
      vertex() const;
  inline ::google::protobuf::RepeatedPtrField< ::ZSS::Protocol::Point >*
      mutable_vertex();

  // required bool FILL = 2;
  inline bool has_fill() const;
  inline void clear_fill();
  static const int kFILLFieldNumber = 2;
  inline bool fill() const;
  inline void set_fill(bool value);

  // @@protoc_insertion_point(class_scope:ZSS.Protocol.Debug_Polygon)
 private:
  inline void set_has_fill();
  inline void clear_has_fill();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ZSS::Protocol::Point > vertex_;
  bool fill_;
  friend void  protobuf_AddDesc_zss_5fdebug_2eproto();
  friend void protobuf_AssignDesc_zss_5fdebug_2eproto();
  friend void protobuf_ShutdownFile_zss_5fdebug_2eproto();

  void InitAsDefaultInstance();
  static Debug_Polygon* default_instance_;
};
// -------------------------------------------------------------------

class Debug_Text : public ::google::protobuf::Message {
 public:
  Debug_Text();
  virtual ~Debug_Text();

  Debug_Text(const Debug_Text& from);

  inline Debug_Text& operator=(const Debug_Text& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Debug_Text& default_instance();

  void Swap(Debug_Text* other);

  // implements Message ----------------------------------------------

  Debug_Text* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Debug_Text& from);
  void MergeFrom(const Debug_Text& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ZSS.Protocol.Point pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline const ::ZSS::Protocol::Point& pos() const;
  inline ::ZSS::Protocol::Point* mutable_pos();
  inline ::ZSS::Protocol::Point* release_pos();
  inline void set_allocated_pos(::ZSS::Protocol::Point* pos);

  // required string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:ZSS.Protocol.Debug_Text)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ZSS::Protocol::Point* pos_;
  ::std::string* text_;
  friend void  protobuf_AddDesc_zss_5fdebug_2eproto();
  friend void protobuf_AssignDesc_zss_5fdebug_2eproto();
  friend void protobuf_ShutdownFile_zss_5fdebug_2eproto();

  void InitAsDefaultInstance();
  static Debug_Text* default_instance_;
};
// -------------------------------------------------------------------

class Debug_Curve_ : public ::google::protobuf::Message {
 public:
  Debug_Curve_();
  virtual ~Debug_Curve_();

  Debug_Curve_(const Debug_Curve_& from);

  inline Debug_Curve_& operator=(const Debug_Curve_& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Debug_Curve_& default_instance();

  void Swap(Debug_Curve_* other);

  // implements Message ----------------------------------------------

  Debug_Curve_* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Debug_Curve_& from);
  void MergeFrom(const Debug_Curve_& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float num = 1;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 1;
  inline float num() const;
  inline void set_num(float value);

  // required float maxLimit = 2;
  inline bool has_maxlimit() const;
  inline void clear_maxlimit();
  static const int kMaxLimitFieldNumber = 2;
  inline float maxlimit() const;
  inline void set_maxlimit(float value);

  // required float minLimit = 3;
  inline bool has_minlimit() const;
  inline void clear_minlimit();
  static const int kMinLimitFieldNumber = 3;
  inline float minlimit() const;
  inline void set_minlimit(float value);

  // @@protoc_insertion_point(class_scope:ZSS.Protocol.Debug_Curve_)
 private:
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_maxlimit();
  inline void clear_has_maxlimit();
  inline void set_has_minlimit();
  inline void clear_has_minlimit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float num_;
  float maxlimit_;
  float minlimit_;
  friend void  protobuf_AddDesc_zss_5fdebug_2eproto();
  friend void protobuf_AssignDesc_zss_5fdebug_2eproto();
  friend void protobuf_ShutdownFile_zss_5fdebug_2eproto();

  void InitAsDefaultInstance();
  static Debug_Curve_* default_instance_;
};
// -------------------------------------------------------------------

class Debug_Curve : public ::google::protobuf::Message {
 public:
  Debug_Curve();
  virtual ~Debug_Curve();

  Debug_Curve(const Debug_Curve& from);

  inline Debug_Curve& operator=(const Debug_Curve& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Debug_Curve& default_instance();

  void Swap(Debug_Curve* other);

  // implements Message ----------------------------------------------

  Debug_Curve* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Debug_Curve& from);
  void MergeFrom(const Debug_Curve& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ZSS.Protocol.Point start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline const ::ZSS::Protocol::Point& start() const;
  inline ::ZSS::Protocol::Point* mutable_start();
  inline ::ZSS::Protocol::Point* release_start();
  inline void set_allocated_start(::ZSS::Protocol::Point* start);

  // required .ZSS.Protocol.Point p1 = 2;
  inline bool has_p1() const;
  inline void clear_p1();
  static const int kP1FieldNumber = 2;
  inline const ::ZSS::Protocol::Point& p1() const;
  inline ::ZSS::Protocol::Point* mutable_p1();
  inline ::ZSS::Protocol::Point* release_p1();
  inline void set_allocated_p1(::ZSS::Protocol::Point* p1);

  // required .ZSS.Protocol.Point p2 = 3;
  inline bool has_p2() const;
  inline void clear_p2();
  static const int kP2FieldNumber = 3;
  inline const ::ZSS::Protocol::Point& p2() const;
  inline ::ZSS::Protocol::Point* mutable_p2();
  inline ::ZSS::Protocol::Point* release_p2();
  inline void set_allocated_p2(::ZSS::Protocol::Point* p2);

  // required .ZSS.Protocol.Point end = 4;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 4;
  inline const ::ZSS::Protocol::Point& end() const;
  inline ::ZSS::Protocol::Point* mutable_end();
  inline ::ZSS::Protocol::Point* release_end();
  inline void set_allocated_end(::ZSS::Protocol::Point* end);

  // @@protoc_insertion_point(class_scope:ZSS.Protocol.Debug_Curve)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_p1();
  inline void clear_has_p1();
  inline void set_has_p2();
  inline void clear_has_p2();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ZSS::Protocol::Point* start_;
  ::ZSS::Protocol::Point* p1_;
  ::ZSS::Protocol::Point* p2_;
  ::ZSS::Protocol::Point* end_;
  friend void  protobuf_AddDesc_zss_5fdebug_2eproto();
  friend void protobuf_AssignDesc_zss_5fdebug_2eproto();
  friend void protobuf_ShutdownFile_zss_5fdebug_2eproto();

  void InitAsDefaultInstance();
  static Debug_Curve* default_instance_;
};
// -------------------------------------------------------------------

class Debug_Msg : public ::google::protobuf::Message {
 public:
  Debug_Msg();
  virtual ~Debug_Msg();

  Debug_Msg(const Debug_Msg& from);

  inline Debug_Msg& operator=(const Debug_Msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Debug_Msg& default_instance();

  void Swap(Debug_Msg* other);

  // implements Message ----------------------------------------------

  Debug_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Debug_Msg& from);
  void MergeFrom(const Debug_Msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Debug_Msg_Debug_Type Debug_Type;
  static const Debug_Type ARC = Debug_Msg_Debug_Type_ARC;
  static const Debug_Type LINE = Debug_Msg_Debug_Type_LINE;
  static const Debug_Type TEXT = Debug_Msg_Debug_Type_TEXT;
  static const Debug_Type ROBOT = Debug_Msg_Debug_Type_ROBOT;
  static const Debug_Type CURVE = Debug_Msg_Debug_Type_CURVE;
  static const Debug_Type POLYGON = Debug_Msg_Debug_Type_POLYGON;
  static inline bool Debug_Type_IsValid(int value) {
    return Debug_Msg_Debug_Type_IsValid(value);
  }
  static const Debug_Type Debug_Type_MIN =
    Debug_Msg_Debug_Type_Debug_Type_MIN;
  static const Debug_Type Debug_Type_MAX =
    Debug_Msg_Debug_Type_Debug_Type_MAX;
  static const int Debug_Type_ARRAYSIZE =
    Debug_Msg_Debug_Type_Debug_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Debug_Type_descriptor() {
    return Debug_Msg_Debug_Type_descriptor();
  }
  static inline const ::std::string& Debug_Type_Name(Debug_Type value) {
    return Debug_Msg_Debug_Type_Name(value);
  }
  static inline bool Debug_Type_Parse(const ::std::string& name,
      Debug_Type* value) {
    return Debug_Msg_Debug_Type_Parse(name, value);
  }

  typedef Debug_Msg_Color Color;
  static const Color WHITE = Debug_Msg_Color_WHITE;
  static const Color RED = Debug_Msg_Color_RED;
  static const Color ORANGE = Debug_Msg_Color_ORANGE;
  static const Color YELLOW = Debug_Msg_Color_YELLOW;
  static const Color GREEN = Debug_Msg_Color_GREEN;
  static const Color CYAN = Debug_Msg_Color_CYAN;
  static const Color BLUE = Debug_Msg_Color_BLUE;
  static const Color PURPLE = Debug_Msg_Color_PURPLE;
  static const Color GRAY = Debug_Msg_Color_GRAY;
  static const Color BLACK = Debug_Msg_Color_BLACK;
  static inline bool Color_IsValid(int value) {
    return Debug_Msg_Color_IsValid(value);
  }
  static const Color Color_MIN =
    Debug_Msg_Color_Color_MIN;
  static const Color Color_MAX =
    Debug_Msg_Color_Color_MAX;
  static const int Color_ARRAYSIZE =
    Debug_Msg_Color_Color_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Color_descriptor() {
    return Debug_Msg_Color_descriptor();
  }
  static inline const ::std::string& Color_Name(Color value) {
    return Debug_Msg_Color_Name(value);
  }
  static inline bool Color_Parse(const ::std::string& name,
      Color* value) {
    return Debug_Msg_Color_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ZSS.Protocol.Debug_Msg.Debug_Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::ZSS::Protocol::Debug_Msg_Debug_Type type() const;
  inline void set_type(::ZSS::Protocol::Debug_Msg_Debug_Type value);

  // required .ZSS.Protocol.Debug_Msg.Color color = 2;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline ::ZSS::Protocol::Debug_Msg_Color color() const;
  inline void set_color(::ZSS::Protocol::Debug_Msg_Color value);

  // optional .ZSS.Protocol.Debug_Arc arc = 3;
  inline bool has_arc() const;
  inline void clear_arc();
  static const int kArcFieldNumber = 3;
  inline const ::ZSS::Protocol::Debug_Arc& arc() const;
  inline ::ZSS::Protocol::Debug_Arc* mutable_arc();
  inline ::ZSS::Protocol::Debug_Arc* release_arc();
  inline void set_allocated_arc(::ZSS::Protocol::Debug_Arc* arc);

  // optional .ZSS.Protocol.Debug_Line line = 4;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 4;
  inline const ::ZSS::Protocol::Debug_Line& line() const;
  inline ::ZSS::Protocol::Debug_Line* mutable_line();
  inline ::ZSS::Protocol::Debug_Line* release_line();
  inline void set_allocated_line(::ZSS::Protocol::Debug_Line* line);

  // optional .ZSS.Protocol.Debug_Text text = 5;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 5;
  inline const ::ZSS::Protocol::Debug_Text& text() const;
  inline ::ZSS::Protocol::Debug_Text* mutable_text();
  inline ::ZSS::Protocol::Debug_Text* release_text();
  inline void set_allocated_text(::ZSS::Protocol::Debug_Text* text);

  // optional .ZSS.Protocol.Debug_Robot robot = 6;
  inline bool has_robot() const;
  inline void clear_robot();
  static const int kRobotFieldNumber = 6;
  inline const ::ZSS::Protocol::Debug_Robot& robot() const;
  inline ::ZSS::Protocol::Debug_Robot* mutable_robot();
  inline ::ZSS::Protocol::Debug_Robot* release_robot();
  inline void set_allocated_robot(::ZSS::Protocol::Debug_Robot* robot);

  // optional .ZSS.Protocol.Debug_Curve_ curve = 7;
  inline bool has_curve() const;
  inline void clear_curve();
  static const int kCurveFieldNumber = 7;
  inline const ::ZSS::Protocol::Debug_Curve_& curve() const;
  inline ::ZSS::Protocol::Debug_Curve_* mutable_curve();
  inline ::ZSS::Protocol::Debug_Curve_* release_curve();
  inline void set_allocated_curve(::ZSS::Protocol::Debug_Curve_* curve);

  // optional .ZSS.Protocol.Debug_Polygon polygon = 8;
  inline bool has_polygon() const;
  inline void clear_polygon();
  static const int kPolygonFieldNumber = 8;
  inline const ::ZSS::Protocol::Debug_Polygon& polygon() const;
  inline ::ZSS::Protocol::Debug_Polygon* mutable_polygon();
  inline ::ZSS::Protocol::Debug_Polygon* release_polygon();
  inline void set_allocated_polygon(::ZSS::Protocol::Debug_Polygon* polygon);

  // @@protoc_insertion_point(class_scope:ZSS.Protocol.Debug_Msg)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_arc();
  inline void clear_has_arc();
  inline void set_has_line();
  inline void clear_has_line();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_robot();
  inline void clear_has_robot();
  inline void set_has_curve();
  inline void clear_has_curve();
  inline void set_has_polygon();
  inline void clear_has_polygon();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  int color_;
  ::ZSS::Protocol::Debug_Arc* arc_;
  ::ZSS::Protocol::Debug_Line* line_;
  ::ZSS::Protocol::Debug_Text* text_;
  ::ZSS::Protocol::Debug_Robot* robot_;
  ::ZSS::Protocol::Debug_Curve_* curve_;
  ::ZSS::Protocol::Debug_Polygon* polygon_;
  friend void  protobuf_AddDesc_zss_5fdebug_2eproto();
  friend void protobuf_AssignDesc_zss_5fdebug_2eproto();
  friend void protobuf_ShutdownFile_zss_5fdebug_2eproto();

  void InitAsDefaultInstance();
  static Debug_Msg* default_instance_;
};
// -------------------------------------------------------------------

class Debug_Msgs : public ::google::protobuf::Message {
 public:
  Debug_Msgs();
  virtual ~Debug_Msgs();

  Debug_Msgs(const Debug_Msgs& from);

  inline Debug_Msgs& operator=(const Debug_Msgs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Debug_Msgs& default_instance();

  void Swap(Debug_Msgs* other);

  // implements Message ----------------------------------------------

  Debug_Msgs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Debug_Msgs& from);
  void MergeFrom(const Debug_Msgs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ZSS.Protocol.Debug_Msg msgs = 1;
  inline int msgs_size() const;
  inline void clear_msgs();
  static const int kMsgsFieldNumber = 1;
  inline const ::ZSS::Protocol::Debug_Msg& msgs(int index) const;
  inline ::ZSS::Protocol::Debug_Msg* mutable_msgs(int index);
  inline ::ZSS::Protocol::Debug_Msg* add_msgs();
  inline const ::google::protobuf::RepeatedPtrField< ::ZSS::Protocol::Debug_Msg >&
      msgs() const;
  inline ::google::protobuf::RepeatedPtrField< ::ZSS::Protocol::Debug_Msg >*
      mutable_msgs();

  // @@protoc_insertion_point(class_scope:ZSS.Protocol.Debug_Msgs)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ZSS::Protocol::Debug_Msg > msgs_;
  friend void  protobuf_AddDesc_zss_5fdebug_2eproto();
  friend void protobuf_AssignDesc_zss_5fdebug_2eproto();
  friend void protobuf_ShutdownFile_zss_5fdebug_2eproto();

  void InitAsDefaultInstance();
  static Debug_Msgs* default_instance_;
};
// ===================================================================


// ===================================================================

// Point

// required float x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Point::x() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Point.x)
  return x_;
}
inline void Point::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:ZSS.Protocol.Point.x)
}

// required float y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Point::y() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Point.y)
  return y_;
}
inline void Point::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:ZSS.Protocol.Point.y)
}

// -------------------------------------------------------------------

// Rectangle

// required .ZSS.Protocol.Point point1 = 1;
inline bool Rectangle::has_point1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rectangle::set_has_point1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rectangle::clear_has_point1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rectangle::clear_point1() {
  if (point1_ != NULL) point1_->::ZSS::Protocol::Point::Clear();
  clear_has_point1();
}
inline const ::ZSS::Protocol::Point& Rectangle::point1() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Rectangle.point1)
  return point1_ != NULL ? *point1_ : *default_instance_->point1_;
}
inline ::ZSS::Protocol::Point* Rectangle::mutable_point1() {
  set_has_point1();
  if (point1_ == NULL) point1_ = new ::ZSS::Protocol::Point;
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Rectangle.point1)
  return point1_;
}
inline ::ZSS::Protocol::Point* Rectangle::release_point1() {
  clear_has_point1();
  ::ZSS::Protocol::Point* temp = point1_;
  point1_ = NULL;
  return temp;
}
inline void Rectangle::set_allocated_point1(::ZSS::Protocol::Point* point1) {
  delete point1_;
  point1_ = point1;
  if (point1) {
    set_has_point1();
  } else {
    clear_has_point1();
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Rectangle.point1)
}

// required .ZSS.Protocol.Point point2 = 2;
inline bool Rectangle::has_point2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rectangle::set_has_point2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rectangle::clear_has_point2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rectangle::clear_point2() {
  if (point2_ != NULL) point2_->::ZSS::Protocol::Point::Clear();
  clear_has_point2();
}
inline const ::ZSS::Protocol::Point& Rectangle::point2() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Rectangle.point2)
  return point2_ != NULL ? *point2_ : *default_instance_->point2_;
}
inline ::ZSS::Protocol::Point* Rectangle::mutable_point2() {
  set_has_point2();
  if (point2_ == NULL) point2_ = new ::ZSS::Protocol::Point;
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Rectangle.point2)
  return point2_;
}
inline ::ZSS::Protocol::Point* Rectangle::release_point2() {
  clear_has_point2();
  ::ZSS::Protocol::Point* temp = point2_;
  point2_ = NULL;
  return temp;
}
inline void Rectangle::set_allocated_point2(::ZSS::Protocol::Point* point2) {
  delete point2_;
  point2_ = point2;
  if (point2) {
    set_has_point2();
  } else {
    clear_has_point2();
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Rectangle.point2)
}

// -------------------------------------------------------------------

// Debug_Robot

// required .ZSS.Protocol.Point pos = 1;
inline bool Debug_Robot::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Debug_Robot::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Debug_Robot::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Debug_Robot::clear_pos() {
  if (pos_ != NULL) pos_->::ZSS::Protocol::Point::Clear();
  clear_has_pos();
}
inline const ::ZSS::Protocol::Point& Debug_Robot::pos() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Robot.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::ZSS::Protocol::Point* Debug_Robot::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::ZSS::Protocol::Point;
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Robot.pos)
  return pos_;
}
inline ::ZSS::Protocol::Point* Debug_Robot::release_pos() {
  clear_has_pos();
  ::ZSS::Protocol::Point* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void Debug_Robot::set_allocated_pos(::ZSS::Protocol::Point* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Debug_Robot.pos)
}

// required float dir = 2;
inline bool Debug_Robot::has_dir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Debug_Robot::set_has_dir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Debug_Robot::clear_has_dir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Debug_Robot::clear_dir() {
  dir_ = 0;
  clear_has_dir();
}
inline float Debug_Robot::dir() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Robot.dir)
  return dir_;
}
inline void Debug_Robot::set_dir(float value) {
  set_has_dir();
  dir_ = value;
  // @@protoc_insertion_point(field_set:ZSS.Protocol.Debug_Robot.dir)
}

// -------------------------------------------------------------------

// Debug_Line

// required .ZSS.Protocol.Point start = 1;
inline bool Debug_Line::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Debug_Line::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Debug_Line::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Debug_Line::clear_start() {
  if (start_ != NULL) start_->::ZSS::Protocol::Point::Clear();
  clear_has_start();
}
inline const ::ZSS::Protocol::Point& Debug_Line::start() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Line.start)
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::ZSS::Protocol::Point* Debug_Line::mutable_start() {
  set_has_start();
  if (start_ == NULL) start_ = new ::ZSS::Protocol::Point;
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Line.start)
  return start_;
}
inline ::ZSS::Protocol::Point* Debug_Line::release_start() {
  clear_has_start();
  ::ZSS::Protocol::Point* temp = start_;
  start_ = NULL;
  return temp;
}
inline void Debug_Line::set_allocated_start(::ZSS::Protocol::Point* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Debug_Line.start)
}

// required .ZSS.Protocol.Point end = 2;
inline bool Debug_Line::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Debug_Line::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Debug_Line::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Debug_Line::clear_end() {
  if (end_ != NULL) end_->::ZSS::Protocol::Point::Clear();
  clear_has_end();
}
inline const ::ZSS::Protocol::Point& Debug_Line::end() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Line.end)
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
inline ::ZSS::Protocol::Point* Debug_Line::mutable_end() {
  set_has_end();
  if (end_ == NULL) end_ = new ::ZSS::Protocol::Point;
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Line.end)
  return end_;
}
inline ::ZSS::Protocol::Point* Debug_Line::release_end() {
  clear_has_end();
  ::ZSS::Protocol::Point* temp = end_;
  end_ = NULL;
  return temp;
}
inline void Debug_Line::set_allocated_end(::ZSS::Protocol::Point* end) {
  delete end_;
  end_ = end;
  if (end) {
    set_has_end();
  } else {
    clear_has_end();
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Debug_Line.end)
}

// required bool FORWARD = 3;
inline bool Debug_Line::has_forward() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Debug_Line::set_has_forward() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Debug_Line::clear_has_forward() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Debug_Line::clear_forward() {
  forward_ = false;
  clear_has_forward();
}
inline bool Debug_Line::forward() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Line.FORWARD)
  return forward_;
}
inline void Debug_Line::set_forward(bool value) {
  set_has_forward();
  forward_ = value;
  // @@protoc_insertion_point(field_set:ZSS.Protocol.Debug_Line.FORWARD)
}

// required bool BACK = 4;
inline bool Debug_Line::has_back() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Debug_Line::set_has_back() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Debug_Line::clear_has_back() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Debug_Line::clear_back() {
  back_ = false;
  clear_has_back();
}
inline bool Debug_Line::back() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Line.BACK)
  return back_;
}
inline void Debug_Line::set_back(bool value) {
  set_has_back();
  back_ = value;
  // @@protoc_insertion_point(field_set:ZSS.Protocol.Debug_Line.BACK)
}

// -------------------------------------------------------------------

// Debug_Arc

// required .ZSS.Protocol.Rectangle rectangle = 1;
inline bool Debug_Arc::has_rectangle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Debug_Arc::set_has_rectangle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Debug_Arc::clear_has_rectangle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Debug_Arc::clear_rectangle() {
  if (rectangle_ != NULL) rectangle_->::ZSS::Protocol::Rectangle::Clear();
  clear_has_rectangle();
}
inline const ::ZSS::Protocol::Rectangle& Debug_Arc::rectangle() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Arc.rectangle)
  return rectangle_ != NULL ? *rectangle_ : *default_instance_->rectangle_;
}
inline ::ZSS::Protocol::Rectangle* Debug_Arc::mutable_rectangle() {
  set_has_rectangle();
  if (rectangle_ == NULL) rectangle_ = new ::ZSS::Protocol::Rectangle;
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Arc.rectangle)
  return rectangle_;
}
inline ::ZSS::Protocol::Rectangle* Debug_Arc::release_rectangle() {
  clear_has_rectangle();
  ::ZSS::Protocol::Rectangle* temp = rectangle_;
  rectangle_ = NULL;
  return temp;
}
inline void Debug_Arc::set_allocated_rectangle(::ZSS::Protocol::Rectangle* rectangle) {
  delete rectangle_;
  rectangle_ = rectangle;
  if (rectangle) {
    set_has_rectangle();
  } else {
    clear_has_rectangle();
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Debug_Arc.rectangle)
}

// required float start = 2;
inline bool Debug_Arc::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Debug_Arc::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Debug_Arc::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Debug_Arc::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline float Debug_Arc::start() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Arc.start)
  return start_;
}
inline void Debug_Arc::set_start(float value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:ZSS.Protocol.Debug_Arc.start)
}

// required float end = 3;
inline bool Debug_Arc::has_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Debug_Arc::set_has_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Debug_Arc::clear_has_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Debug_Arc::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline float Debug_Arc::end() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Arc.end)
  return end_;
}
inline void Debug_Arc::set_end(float value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:ZSS.Protocol.Debug_Arc.end)
}

// required bool FILL = 4;
inline bool Debug_Arc::has_fill() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Debug_Arc::set_has_fill() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Debug_Arc::clear_has_fill() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Debug_Arc::clear_fill() {
  fill_ = false;
  clear_has_fill();
}
inline bool Debug_Arc::fill() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Arc.FILL)
  return fill_;
}
inline void Debug_Arc::set_fill(bool value) {
  set_has_fill();
  fill_ = value;
  // @@protoc_insertion_point(field_set:ZSS.Protocol.Debug_Arc.FILL)
}

// -------------------------------------------------------------------

// Debug_Polygon

// repeated .ZSS.Protocol.Point vertex = 1;
inline int Debug_Polygon::vertex_size() const {
  return vertex_.size();
}
inline void Debug_Polygon::clear_vertex() {
  vertex_.Clear();
}
inline const ::ZSS::Protocol::Point& Debug_Polygon::vertex(int index) const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Polygon.vertex)
  return vertex_.Get(index);
}
inline ::ZSS::Protocol::Point* Debug_Polygon::mutable_vertex(int index) {
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Polygon.vertex)
  return vertex_.Mutable(index);
}
inline ::ZSS::Protocol::Point* Debug_Polygon::add_vertex() {
  // @@protoc_insertion_point(field_add:ZSS.Protocol.Debug_Polygon.vertex)
  return vertex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ZSS::Protocol::Point >&
Debug_Polygon::vertex() const {
  // @@protoc_insertion_point(field_list:ZSS.Protocol.Debug_Polygon.vertex)
  return vertex_;
}
inline ::google::protobuf::RepeatedPtrField< ::ZSS::Protocol::Point >*
Debug_Polygon::mutable_vertex() {
  // @@protoc_insertion_point(field_mutable_list:ZSS.Protocol.Debug_Polygon.vertex)
  return &vertex_;
}

// required bool FILL = 2;
inline bool Debug_Polygon::has_fill() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Debug_Polygon::set_has_fill() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Debug_Polygon::clear_has_fill() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Debug_Polygon::clear_fill() {
  fill_ = false;
  clear_has_fill();
}
inline bool Debug_Polygon::fill() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Polygon.FILL)
  return fill_;
}
inline void Debug_Polygon::set_fill(bool value) {
  set_has_fill();
  fill_ = value;
  // @@protoc_insertion_point(field_set:ZSS.Protocol.Debug_Polygon.FILL)
}

// -------------------------------------------------------------------

// Debug_Text

// required .ZSS.Protocol.Point pos = 1;
inline bool Debug_Text::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Debug_Text::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Debug_Text::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Debug_Text::clear_pos() {
  if (pos_ != NULL) pos_->::ZSS::Protocol::Point::Clear();
  clear_has_pos();
}
inline const ::ZSS::Protocol::Point& Debug_Text::pos() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Text.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::ZSS::Protocol::Point* Debug_Text::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::ZSS::Protocol::Point;
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Text.pos)
  return pos_;
}
inline ::ZSS::Protocol::Point* Debug_Text::release_pos() {
  clear_has_pos();
  ::ZSS::Protocol::Point* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void Debug_Text::set_allocated_pos(::ZSS::Protocol::Point* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Debug_Text.pos)
}

// required string text = 2;
inline bool Debug_Text::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Debug_Text::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Debug_Text::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Debug_Text::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Debug_Text::text() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Text.text)
  return *text_;
}
inline void Debug_Text::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set:ZSS.Protocol.Debug_Text.text)
}
inline void Debug_Text::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set_char:ZSS.Protocol.Debug_Text.text)
}
inline void Debug_Text::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ZSS.Protocol.Debug_Text.text)
}
inline ::std::string* Debug_Text::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Text.text)
  return text_;
}
inline ::std::string* Debug_Text::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Debug_Text::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Debug_Text.text)
}

// -------------------------------------------------------------------

// Debug_Curve_

// required float num = 1;
inline bool Debug_Curve_::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Debug_Curve_::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Debug_Curve_::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Debug_Curve_::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline float Debug_Curve_::num() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Curve_.num)
  return num_;
}
inline void Debug_Curve_::set_num(float value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:ZSS.Protocol.Debug_Curve_.num)
}

// required float maxLimit = 2;
inline bool Debug_Curve_::has_maxlimit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Debug_Curve_::set_has_maxlimit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Debug_Curve_::clear_has_maxlimit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Debug_Curve_::clear_maxlimit() {
  maxlimit_ = 0;
  clear_has_maxlimit();
}
inline float Debug_Curve_::maxlimit() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Curve_.maxLimit)
  return maxlimit_;
}
inline void Debug_Curve_::set_maxlimit(float value) {
  set_has_maxlimit();
  maxlimit_ = value;
  // @@protoc_insertion_point(field_set:ZSS.Protocol.Debug_Curve_.maxLimit)
}

// required float minLimit = 3;
inline bool Debug_Curve_::has_minlimit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Debug_Curve_::set_has_minlimit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Debug_Curve_::clear_has_minlimit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Debug_Curve_::clear_minlimit() {
  minlimit_ = 0;
  clear_has_minlimit();
}
inline float Debug_Curve_::minlimit() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Curve_.minLimit)
  return minlimit_;
}
inline void Debug_Curve_::set_minlimit(float value) {
  set_has_minlimit();
  minlimit_ = value;
  // @@protoc_insertion_point(field_set:ZSS.Protocol.Debug_Curve_.minLimit)
}

// -------------------------------------------------------------------

// Debug_Curve

// required .ZSS.Protocol.Point start = 1;
inline bool Debug_Curve::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Debug_Curve::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Debug_Curve::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Debug_Curve::clear_start() {
  if (start_ != NULL) start_->::ZSS::Protocol::Point::Clear();
  clear_has_start();
}
inline const ::ZSS::Protocol::Point& Debug_Curve::start() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Curve.start)
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::ZSS::Protocol::Point* Debug_Curve::mutable_start() {
  set_has_start();
  if (start_ == NULL) start_ = new ::ZSS::Protocol::Point;
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Curve.start)
  return start_;
}
inline ::ZSS::Protocol::Point* Debug_Curve::release_start() {
  clear_has_start();
  ::ZSS::Protocol::Point* temp = start_;
  start_ = NULL;
  return temp;
}
inline void Debug_Curve::set_allocated_start(::ZSS::Protocol::Point* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Debug_Curve.start)
}

// required .ZSS.Protocol.Point p1 = 2;
inline bool Debug_Curve::has_p1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Debug_Curve::set_has_p1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Debug_Curve::clear_has_p1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Debug_Curve::clear_p1() {
  if (p1_ != NULL) p1_->::ZSS::Protocol::Point::Clear();
  clear_has_p1();
}
inline const ::ZSS::Protocol::Point& Debug_Curve::p1() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Curve.p1)
  return p1_ != NULL ? *p1_ : *default_instance_->p1_;
}
inline ::ZSS::Protocol::Point* Debug_Curve::mutable_p1() {
  set_has_p1();
  if (p1_ == NULL) p1_ = new ::ZSS::Protocol::Point;
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Curve.p1)
  return p1_;
}
inline ::ZSS::Protocol::Point* Debug_Curve::release_p1() {
  clear_has_p1();
  ::ZSS::Protocol::Point* temp = p1_;
  p1_ = NULL;
  return temp;
}
inline void Debug_Curve::set_allocated_p1(::ZSS::Protocol::Point* p1) {
  delete p1_;
  p1_ = p1;
  if (p1) {
    set_has_p1();
  } else {
    clear_has_p1();
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Debug_Curve.p1)
}

// required .ZSS.Protocol.Point p2 = 3;
inline bool Debug_Curve::has_p2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Debug_Curve::set_has_p2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Debug_Curve::clear_has_p2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Debug_Curve::clear_p2() {
  if (p2_ != NULL) p2_->::ZSS::Protocol::Point::Clear();
  clear_has_p2();
}
inline const ::ZSS::Protocol::Point& Debug_Curve::p2() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Curve.p2)
  return p2_ != NULL ? *p2_ : *default_instance_->p2_;
}
inline ::ZSS::Protocol::Point* Debug_Curve::mutable_p2() {
  set_has_p2();
  if (p2_ == NULL) p2_ = new ::ZSS::Protocol::Point;
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Curve.p2)
  return p2_;
}
inline ::ZSS::Protocol::Point* Debug_Curve::release_p2() {
  clear_has_p2();
  ::ZSS::Protocol::Point* temp = p2_;
  p2_ = NULL;
  return temp;
}
inline void Debug_Curve::set_allocated_p2(::ZSS::Protocol::Point* p2) {
  delete p2_;
  p2_ = p2;
  if (p2) {
    set_has_p2();
  } else {
    clear_has_p2();
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Debug_Curve.p2)
}

// required .ZSS.Protocol.Point end = 4;
inline bool Debug_Curve::has_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Debug_Curve::set_has_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Debug_Curve::clear_has_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Debug_Curve::clear_end() {
  if (end_ != NULL) end_->::ZSS::Protocol::Point::Clear();
  clear_has_end();
}
inline const ::ZSS::Protocol::Point& Debug_Curve::end() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Curve.end)
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
inline ::ZSS::Protocol::Point* Debug_Curve::mutable_end() {
  set_has_end();
  if (end_ == NULL) end_ = new ::ZSS::Protocol::Point;
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Curve.end)
  return end_;
}
inline ::ZSS::Protocol::Point* Debug_Curve::release_end() {
  clear_has_end();
  ::ZSS::Protocol::Point* temp = end_;
  end_ = NULL;
  return temp;
}
inline void Debug_Curve::set_allocated_end(::ZSS::Protocol::Point* end) {
  delete end_;
  end_ = end;
  if (end) {
    set_has_end();
  } else {
    clear_has_end();
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Debug_Curve.end)
}

// -------------------------------------------------------------------

// Debug_Msg

// required .ZSS.Protocol.Debug_Msg.Debug_Type type = 1;
inline bool Debug_Msg::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Debug_Msg::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Debug_Msg::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Debug_Msg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ZSS::Protocol::Debug_Msg_Debug_Type Debug_Msg::type() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Msg.type)
  return static_cast< ::ZSS::Protocol::Debug_Msg_Debug_Type >(type_);
}
inline void Debug_Msg::set_type(::ZSS::Protocol::Debug_Msg_Debug_Type value) {
  assert(::ZSS::Protocol::Debug_Msg_Debug_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ZSS.Protocol.Debug_Msg.type)
}

// required .ZSS.Protocol.Debug_Msg.Color color = 2;
inline bool Debug_Msg::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Debug_Msg::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Debug_Msg::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Debug_Msg::clear_color() {
  color_ = 0;
  clear_has_color();
}
inline ::ZSS::Protocol::Debug_Msg_Color Debug_Msg::color() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Msg.color)
  return static_cast< ::ZSS::Protocol::Debug_Msg_Color >(color_);
}
inline void Debug_Msg::set_color(::ZSS::Protocol::Debug_Msg_Color value) {
  assert(::ZSS::Protocol::Debug_Msg_Color_IsValid(value));
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:ZSS.Protocol.Debug_Msg.color)
}

// optional .ZSS.Protocol.Debug_Arc arc = 3;
inline bool Debug_Msg::has_arc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Debug_Msg::set_has_arc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Debug_Msg::clear_has_arc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Debug_Msg::clear_arc() {
  if (arc_ != NULL) arc_->::ZSS::Protocol::Debug_Arc::Clear();
  clear_has_arc();
}
inline const ::ZSS::Protocol::Debug_Arc& Debug_Msg::arc() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Msg.arc)
  return arc_ != NULL ? *arc_ : *default_instance_->arc_;
}
inline ::ZSS::Protocol::Debug_Arc* Debug_Msg::mutable_arc() {
  set_has_arc();
  if (arc_ == NULL) arc_ = new ::ZSS::Protocol::Debug_Arc;
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Msg.arc)
  return arc_;
}
inline ::ZSS::Protocol::Debug_Arc* Debug_Msg::release_arc() {
  clear_has_arc();
  ::ZSS::Protocol::Debug_Arc* temp = arc_;
  arc_ = NULL;
  return temp;
}
inline void Debug_Msg::set_allocated_arc(::ZSS::Protocol::Debug_Arc* arc) {
  delete arc_;
  arc_ = arc;
  if (arc) {
    set_has_arc();
  } else {
    clear_has_arc();
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Debug_Msg.arc)
}

// optional .ZSS.Protocol.Debug_Line line = 4;
inline bool Debug_Msg::has_line() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Debug_Msg::set_has_line() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Debug_Msg::clear_has_line() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Debug_Msg::clear_line() {
  if (line_ != NULL) line_->::ZSS::Protocol::Debug_Line::Clear();
  clear_has_line();
}
inline const ::ZSS::Protocol::Debug_Line& Debug_Msg::line() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Msg.line)
  return line_ != NULL ? *line_ : *default_instance_->line_;
}
inline ::ZSS::Protocol::Debug_Line* Debug_Msg::mutable_line() {
  set_has_line();
  if (line_ == NULL) line_ = new ::ZSS::Protocol::Debug_Line;
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Msg.line)
  return line_;
}
inline ::ZSS::Protocol::Debug_Line* Debug_Msg::release_line() {
  clear_has_line();
  ::ZSS::Protocol::Debug_Line* temp = line_;
  line_ = NULL;
  return temp;
}
inline void Debug_Msg::set_allocated_line(::ZSS::Protocol::Debug_Line* line) {
  delete line_;
  line_ = line;
  if (line) {
    set_has_line();
  } else {
    clear_has_line();
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Debug_Msg.line)
}

// optional .ZSS.Protocol.Debug_Text text = 5;
inline bool Debug_Msg::has_text() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Debug_Msg::set_has_text() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Debug_Msg::clear_has_text() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Debug_Msg::clear_text() {
  if (text_ != NULL) text_->::ZSS::Protocol::Debug_Text::Clear();
  clear_has_text();
}
inline const ::ZSS::Protocol::Debug_Text& Debug_Msg::text() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Msg.text)
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::ZSS::Protocol::Debug_Text* Debug_Msg::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::ZSS::Protocol::Debug_Text;
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Msg.text)
  return text_;
}
inline ::ZSS::Protocol::Debug_Text* Debug_Msg::release_text() {
  clear_has_text();
  ::ZSS::Protocol::Debug_Text* temp = text_;
  text_ = NULL;
  return temp;
}
inline void Debug_Msg::set_allocated_text(::ZSS::Protocol::Debug_Text* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Debug_Msg.text)
}

// optional .ZSS.Protocol.Debug_Robot robot = 6;
inline bool Debug_Msg::has_robot() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Debug_Msg::set_has_robot() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Debug_Msg::clear_has_robot() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Debug_Msg::clear_robot() {
  if (robot_ != NULL) robot_->::ZSS::Protocol::Debug_Robot::Clear();
  clear_has_robot();
}
inline const ::ZSS::Protocol::Debug_Robot& Debug_Msg::robot() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Msg.robot)
  return robot_ != NULL ? *robot_ : *default_instance_->robot_;
}
inline ::ZSS::Protocol::Debug_Robot* Debug_Msg::mutable_robot() {
  set_has_robot();
  if (robot_ == NULL) robot_ = new ::ZSS::Protocol::Debug_Robot;
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Msg.robot)
  return robot_;
}
inline ::ZSS::Protocol::Debug_Robot* Debug_Msg::release_robot() {
  clear_has_robot();
  ::ZSS::Protocol::Debug_Robot* temp = robot_;
  robot_ = NULL;
  return temp;
}
inline void Debug_Msg::set_allocated_robot(::ZSS::Protocol::Debug_Robot* robot) {
  delete robot_;
  robot_ = robot;
  if (robot) {
    set_has_robot();
  } else {
    clear_has_robot();
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Debug_Msg.robot)
}

// optional .ZSS.Protocol.Debug_Curve_ curve = 7;
inline bool Debug_Msg::has_curve() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Debug_Msg::set_has_curve() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Debug_Msg::clear_has_curve() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Debug_Msg::clear_curve() {
  if (curve_ != NULL) curve_->::ZSS::Protocol::Debug_Curve_::Clear();
  clear_has_curve();
}
inline const ::ZSS::Protocol::Debug_Curve_& Debug_Msg::curve() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Msg.curve)
  return curve_ != NULL ? *curve_ : *default_instance_->curve_;
}
inline ::ZSS::Protocol::Debug_Curve_* Debug_Msg::mutable_curve() {
  set_has_curve();
  if (curve_ == NULL) curve_ = new ::ZSS::Protocol::Debug_Curve_;
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Msg.curve)
  return curve_;
}
inline ::ZSS::Protocol::Debug_Curve_* Debug_Msg::release_curve() {
  clear_has_curve();
  ::ZSS::Protocol::Debug_Curve_* temp = curve_;
  curve_ = NULL;
  return temp;
}
inline void Debug_Msg::set_allocated_curve(::ZSS::Protocol::Debug_Curve_* curve) {
  delete curve_;
  curve_ = curve;
  if (curve) {
    set_has_curve();
  } else {
    clear_has_curve();
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Debug_Msg.curve)
}

// optional .ZSS.Protocol.Debug_Polygon polygon = 8;
inline bool Debug_Msg::has_polygon() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Debug_Msg::set_has_polygon() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Debug_Msg::clear_has_polygon() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Debug_Msg::clear_polygon() {
  if (polygon_ != NULL) polygon_->::ZSS::Protocol::Debug_Polygon::Clear();
  clear_has_polygon();
}
inline const ::ZSS::Protocol::Debug_Polygon& Debug_Msg::polygon() const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Msg.polygon)
  return polygon_ != NULL ? *polygon_ : *default_instance_->polygon_;
}
inline ::ZSS::Protocol::Debug_Polygon* Debug_Msg::mutable_polygon() {
  set_has_polygon();
  if (polygon_ == NULL) polygon_ = new ::ZSS::Protocol::Debug_Polygon;
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Msg.polygon)
  return polygon_;
}
inline ::ZSS::Protocol::Debug_Polygon* Debug_Msg::release_polygon() {
  clear_has_polygon();
  ::ZSS::Protocol::Debug_Polygon* temp = polygon_;
  polygon_ = NULL;
  return temp;
}
inline void Debug_Msg::set_allocated_polygon(::ZSS::Protocol::Debug_Polygon* polygon) {
  delete polygon_;
  polygon_ = polygon;
  if (polygon) {
    set_has_polygon();
  } else {
    clear_has_polygon();
  }
  // @@protoc_insertion_point(field_set_allocated:ZSS.Protocol.Debug_Msg.polygon)
}

// -------------------------------------------------------------------

// Debug_Msgs

// repeated .ZSS.Protocol.Debug_Msg msgs = 1;
inline int Debug_Msgs::msgs_size() const {
  return msgs_.size();
}
inline void Debug_Msgs::clear_msgs() {
  msgs_.Clear();
}
inline const ::ZSS::Protocol::Debug_Msg& Debug_Msgs::msgs(int index) const {
  // @@protoc_insertion_point(field_get:ZSS.Protocol.Debug_Msgs.msgs)
  return msgs_.Get(index);
}
inline ::ZSS::Protocol::Debug_Msg* Debug_Msgs::mutable_msgs(int index) {
  // @@protoc_insertion_point(field_mutable:ZSS.Protocol.Debug_Msgs.msgs)
  return msgs_.Mutable(index);
}
inline ::ZSS::Protocol::Debug_Msg* Debug_Msgs::add_msgs() {
  // @@protoc_insertion_point(field_add:ZSS.Protocol.Debug_Msgs.msgs)
  return msgs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ZSS::Protocol::Debug_Msg >&
Debug_Msgs::msgs() const {
  // @@protoc_insertion_point(field_list:ZSS.Protocol.Debug_Msgs.msgs)
  return msgs_;
}
inline ::google::protobuf::RepeatedPtrField< ::ZSS::Protocol::Debug_Msg >*
Debug_Msgs::mutable_msgs() {
  // @@protoc_insertion_point(field_mutable_list:ZSS.Protocol.Debug_Msgs.msgs)
  return &msgs_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol
}  // namespace ZSS

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ZSS::Protocol::Debug_Msg_Debug_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ZSS::Protocol::Debug_Msg_Debug_Type>() {
  return ::ZSS::Protocol::Debug_Msg_Debug_Type_descriptor();
}
template <> struct is_proto_enum< ::ZSS::Protocol::Debug_Msg_Color> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ZSS::Protocol::Debug_Msg_Color>() {
  return ::ZSS::Protocol::Debug_Msg_Color_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_zss_5fdebug_2eproto__INCLUDED
